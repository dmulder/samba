#!/usr/bin/env python
# Copyright Luke Morrison <luc785@.hotmail.com> July 2013
# Co-Edited by Matthieu Pattou July 2013 from original August 2013
# Edited by Garming Sam Feb. 2014
# Edited by Luke Morrison April 2014

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

'''This script reads a log file of previous GPO, gets all GPO from sysvol
and sorts them by container. Then, it applies the ones that haven't been
applied, have changed, or is in the right container'''

import os
import fcntl
import sys
import tempfile
import subprocess

sys.path.insert(0, "bin/python")

import samba
import optparse
from samba import getopt as options
from samba.gpclass import *
from samba.net import Net
from samba.dcerpc import nbt
from samba import smb

# Finds all GPO Files ending in inf
def gp_path_list(path):

    GPO_LIST = []
    for ext in gp_extensions:
        GPO_LIST.append((ext, ext.list(path)))
    return GPO_LIST

# Reads the GPOs and sends them to their proper handlers
def gpo_parser(GPO_LIST, ldb, conn):
    for entry in GPO_LIST:
        (ext, thefile) = entry
        ext.parse(thefile, ldb, conn)


class GPOServiceSetup:
    def __init__(self):
        """Initialize all components necessary to return instances of
        a Samba lp context (smb.conf) and Samba LDB context
        """

        self.parser = optparse.OptionParser("testsearchdn [options]")
        self.sambaopts = options.SambaOptions(self.parser)
        self.credopts = None
        self.opts = None
        self.args = None
        self.lp = None
        self.smbconf = None
        self.creds = None
        self.url = None

    # Setters or Initializers
    def init_parser(self):
        '''Get the command line options'''
        self.parser.add_option_group(self.sambaopts)
        self.parser.add_option_group(options.VersionOptions(self.parser))
        self.init_credopts()
        self.parser.add_option("-H", dest="url", help="URL for the samdb")
        self.parser.add_option_group(self.credopts)

    def init_argsopts(self):
        '''Set the options and the arguments'''
        (opts, args) = self.parser.parse_args()

        self.opts = opts
        self.args = args

    def init_credopts(self):
        '''Set Credential operations'''
        self.credopts = options.CredentialsOptions(self.parser)

    def init_lp(self):
        '''Set the loadparm context'''
        self.lp = self.sambaopts.get_loadparm()
        self.smbconf = self.lp.configfile
        if (not self.opts.url):
            self.url = self.lp.samdb_url()
        else:
            self.url = self.opts.url

    def init_session(self):
        '''Initialize the session'''
        self.creds = self.credopts.get_credentials(self.lp,
            fallback_machine=True)
        self.session = system_session()

    def InitializeService(self):
        '''Inializer for the thread'''
        self.init_parser()
        self.init_argsopts()
        self.init_lp()
        self.init_session()

    # Getters
    def Get_LDB(self):
        '''Return a live instance of Samba'''
        SambaDB = SamDB(self.url, session_info=self.session,
            credentials=self.creds, lp=self.lp)
        return SambaDB

    def Get_lp_Content(self):
        '''Return an instance of a local lp context'''
        return self.lp

    def Get_Creds(self):
        '''Return an instance of a local creds'''
        return self.creds


def GetBackLog(sys_log):
    """Reads BackLog and makes thread aware of which GPO are unchanged or empty
    :param String sys_log: path to backLog
    :return Dictionary previous_scanned_version: {Unedited GPO: Version Number}
    *NOTE on Version below
    """
    previous_scanned_version = {}
    if os.path.isfile(sys_log):
        previous_scanned_version = scan_log(sys_log)
        return previous_scanned_version
    else:
        return None

# Set up the GPO service
GPOService = GPOServiceSetup()
GPOService.InitializeService()

# Get the Samba Instance
test_ldb = GPOService.Get_LDB()

# Get The lp context
lp = GPOService.Get_lp_Content()

# Get the CREDS
creds = GPOService.Get_Creds()

# Read the readable backLog into a hashmap
# then open writable backLog in same location
BackLoggedGPO = None
sys_log = '%s/%s' % (lp.get("path", "sysvol"), 'syslog.txt')
BackLoggedGPO = GetBackLog(sys_log)
BackLog = open(sys_log, "w")


# We need to know writable DC to setup SMB connection
net = Net(creds=creds, lp=lp)
cldap_ret = net.finddc(domain=lp.get('realm'), flags=(nbt.NBT_SERVER_LDAP |
    nbt.NBT_SERVER_DS |
    nbt.NBT_SERVER_WRITABLE))
dc_hostname = cldap_ret.pdc_dns_name

try:
    conn = smb.SMB(dc_hostname, 'sysvol', lp=lp, creds=creds)
except Exception, e:
    raise Exception("Error connecting to '%s' using SMB" % dc_hostname, e)

# Get the dn of the domain, and the dn of readable/writable DC
global_dn = test_ldb.domain_dn()
DC_OU = "OU=Domain Controllers" + ',' + global_dn

# Set up a List of the GUID for all GPO's
guid_list = [x['name'] for x in conn.list('%s/Policies' % lp.get("realm").lower())]

#Establish the Hierarchy for the GPO
hierarchy_gpos = samba4_gpo_hierarchy(test_ldb, guid_list, DC_OU, global_dn)
hierarchy_gpos.establish_hierarchy()

#Write applicable GPO

for guid_eval in hierarchy_gpos.sorted_full:
    guid = guid_eval[0]
    gp_extensions = [gp_sec_ext()]
    local_path = '%s/Policies' % lp.get("realm").lower() + '/' + guid + '/'
    version = gpo.gpo_get_sysvol_gpt_version(lp.get("path", "sysvol") + '/' + local_path)[1]

    gpolist = gp_path_list(local_path)
    print local_path

    '''If an important GPO parse it. Will not parse if it has not changed, is empty, or is not in the right container'''
    if guid_eval[1]:
        if gpolist[0][1]:
            if (version != BackLoggedGPO.get(guid)) and (version != 0):
                print ('GPO %s has changed' % guid)
                gpo_parser(gpolist, test_ldb, conn)

    BackLog.write('%s %i\n' % (guid, version))

